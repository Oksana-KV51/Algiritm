#Пузырьковая сортировка работает путем многократного прохода по массиву,
# сравнивая соседние элементы и меняя их местами, если они находятся в неправильном
# порядке. Процесс продолжается до тех пор, пока массив не будет отсортирован.
#Пузырьковая сортировка (Bubble Sort)**:
   #- Простой, но неэффективный алгоритм.
   #- Постепенно "всплывает" наибольший элемент к концу списка.

mas = [5, 7, 4, 3, 8, 2]
n = len(mas)

for i in range(n):
    for j in range(0, n - i - 1):
        if mas[j] > mas[j + 1]:
            mas[j], mas[j + 1] = mas[j + 1], mas[j]
print(f'Пузырьковая сортировка \n {mas}')

#Быстрая сортировка (Quick Sort) использует метод «разделяй и властвуй». Она выбирает опорный элемент
# (pivot) и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.
# Затем сортировка применяется рекурсивно к каждой части.

def quick_sort(s):
    if len(s) <= 1:
        return s
    element = s[0] #для старта
    left = list(filter(lambda i: i < element, s))
    center = [i for i in s if i == element]
    right = list(filter(lambda i: i > element, s))
#Рекурсия необходима для обработке каждой внутренней части структуры данных независимо.
# Это позволяет работать с любым количеством вложенных элементов, как левых, так и правых
# списков, и сортировать их по отдельности. Такой подход обеспечивает гибкость и эффективность
# при решении сложных задач сортировки и других алгоритмических операций.
    return quick_sort(left) + center + quick_sort(right)

print(f'Быстрая сортировка (Quick Sort) \n {quick_sort([5, 2, 9, 0, 1, 5, 3])}')


#Сортировка выбором (Selection Sort) работает путем поиска минимального элемента в неотсортированной части массива
# и его обмена с первым элементом этой части. Затем процесс повторяется для оставшейся части массива.
a = [-3, 5, 0, -8, 1, 10]
def selection_sort(arr):
   for i in range(len(arr)):
       #Мы предполагаем, что первый элемент в неотсортированной части — это минимальный элемент.
       min_index = i
       #ищем минимальный элемент
       for j in range(i+1, len(arr)):
           if arr[j] < arr[min_index]:
               min_index = j
      #Меняем местами найденный минимальный элемент с первым элементом в неотсортированной части массива.
       arr[i], arr[min_index] = arr[min_index], arr[i]

selection_sort(a)
print(f'Сортировка выбором (Selection Sort) \n {a}')

#Сортировка вставками (Insertion Sort) работает путем последовательного перемещения элементов массива,
# вставляя каждый элемент на его правильное место в уже отсортированной части массива.

a = [-3, 5, 0, -8, 1, 10]

def insert_sort(arr):
    for i in range(1, len(arr)):
        #Сохраняем текущий элемент в переменной key.
        key = arr[i]
        #Для сравнения текущей переменной с отсортированными сохраняем индекс предыдущего
        # элемента в переменной j (для сравнения).
        j = i - 1
        while j >= 0 and arr[j] > key:
            #Сдвигаем элемент arr[j] вправо на одну позицию и указываем переход к следующему
            # элементу влево.
            arr[j + 1] = arr[j]
            j -= 1
        #Вставляем текущий элемент, на котором находится цикл на правильное место.
        arr[j + 1] = key

insert_sort(a)
print(f'Сортировка вставками (Insertion Sort) \n {a}')

#Сортировка слиянием (Merge Sort)**:
   #- Разделяет массив на две части, сортирует их и затем объединяет.
   #- Использует принцип "разделяй и властвуй".
   #- Эффективен и стабилен, имеет временную сложность O(n log n).
def merge_sort(arr):
    # Базовый случай рекурсии: если длина массива меньше или равна 1, он уже отсортирован
    if len(arr) <= 1:
        return arr

    # Найдем середину массива
    mid = len(arr) // 2

    # Разделим массив на две половины
    left_half = arr[:mid]
    right_half = arr[mid:]

    # Рекурсивно применим merge_sort к каждой половине
    left_sorted = merge_sort(left_half)
    right_sorted = merge_sort(right_half)

    # Объединим отсортированные половины
    return merge(left_sorted, right_sorted)

def merge(left, right):
    result = []
    left_index = 0
    right_index = 0

    # Объединяем два отсортированных массива в один
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            result.append(left[left_index])
            left_index += 1
        else:
            result.append(right[right_index])
            right_index += 1

    # Если в одном из массивов остались элементы, добавляем их в результат
    result.extend(left[left_index:])
    result.extend(right[right_index:])

    return result

# Пример использования
arr = [5, 7, 4, 3, 8, 2]
sorted_arr = merge_sort(arr)
print(f'Сортировка слиянием (Merge Sort) \n {sorted_arr}')


#Сортировка кучей (Heap Sort)**:
   #- Основывается на структуре данных "куча" (heap).
   #- Преобразует массив в кучу, а затем извлекает элементы из кучи, создавая отсортированный массив.
   # - Имеет временную сложность O(n log n).
def heapify(arr, n, i):
    # Находим наибольший среди корня, левого потомка и правого потомка
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    # Проверяем, если левый потомок больше корня
    if left < n and arr[i] < arr[left]:
        largest = left

    # Проверяем, если правый потомок больше чем наибольший элемент на данный момент
    if right < n and arr[largest] < arr[right]:
        largest = right

    # Если наибольший элемент не корень
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Меняем
        # Рекурсивно heapify поддерево
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    # Построение max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    # Один за другим извлекаем элементы
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # Перемещаем текущий корень в конец
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print(f"Сортировка кучей (Heap Sort) \n {arr}")


#Сортировка Шелла (Shell Sort)**:
   #- Является улучшенной версией сортировки вставками.
   #- Сортирует элементы, расположенные на определённом расстоянии друг от друга, постепенно уменьшая это расстояние.


#Поразрядная сортировка (Radix Sort)**:
   #- Сортирует числа по разрядам, начиная с наименее значащего разряда.
   #- Часто используется для сортировки целых чисел или строк фиксированной длины.


#Сортировка подсчётом (Counting Sort)**:
   #- Эффективен для сортировки небольших чисел или чисел в ограниченном диапазоне.
   #- Использует дополнительный массив для подсчёта количества вхождений каждого значения.


#Блочная сортировка (Bucket Sort)**:
   #- Разделяет элементы на несколько "ведер" (подмассивов),
# которые сортируются отдельно (обычно с помощью другого алгоритма сортировки).
